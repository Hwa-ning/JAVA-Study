# 상속
- OOP의 핵심 키워드중 하나인 상속에 관한 글이다. 상속은 코드를 재사용함에 있어서 큰 장점을 가지고 있있지만 문제를 야기할 수 있으므로 상황에 맞게 사용하는 것이 중요하다.

## 상속시 유의할 점
1. 하위 클래스에서의 재정의(overriding)시 접근제어자는 부모 클래스보다 같거나 낮은 수준의 접근제어자만을 가질 수 있다. 
``` JAVA
class Data{
    int getTen(){
        return 10;
    }
}

class Child_Data extends Data{
    @Override
    private int getTen(){
        return 20;
    }
}
```
위 코드에서 Child_Data 클래스의 getTen은 불가능한 문법이다. default보다 높은 수준의 접근제어자인 private 접근제어자로 재정의를 하려고 하기 때문이다.

2. 


## 상속에서의 문제점

### 불필요한 클래스까지 상속받는다.

![image](https://user-images.githubusercontent.com/69469529/186693225-d1be5671-6139-4e70-9dae-ad5c89f76f35.png)

JAVA API에서 Stack의 경우 Vector를 상속한 클래스이다.

```Java
public class Main{
    public static void main(String[] args) {
        Stack<String> stack = new Stack<>();
        stack.push("First");
        stack.push("Second");
        stack.add(0, "Third");
        System.out.println(stack.top());
    }
}
```

Vector에 add는 상위 클래스의 모든 멤버를 상속받게 되므로 Stack에도 add 메소드는 반드시 존재하게 된다.
Vector에 요소를 추가할 때 사용하는 public method이고 Stack 클래스에선 이 상위 클래스의
public method를 private과 같이 더 강력한 수준의 접근제어자로 가리거나 없앨 수 없다.


```Java
public class CustomHashSet<E> extends HashSet<E>{
    private int count;
  
    @Override
    public boolean add(E e){
        count++;
        return super.add(e);
    }
  
    @Override
    public boolean addAll(Collection<? extends E> c) {
        count += c.size();
        return super.addAll(c);
    }

    public int getCount(){
        return count;
    }
}
```

